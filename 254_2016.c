#pragma config(Sensor, in1,    cLeft,          sensorPotentiometer)
#pragma config(Sensor, in2,    cRight,         sensorPotentiometer)
#pragma config(Motor,  port1,           lBRight,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dTRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rClaw,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           dTLeft,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lTRight,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           dBLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lTLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dBRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          lBLeft,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2);
#pragma competitionControl(Competition);
#include "Vex_Competition_Includes.c";

// d at beginning means drive
// l at beginning beans lift
// r & l at beginning are for claw

// TODO: get the potentiometers working
// TODO: refactor code for auton & make auton

const int MAX_MOTOR_POWER = 127;
const int DEADZONE = 10;
const int CLAW_SPEED = 70;

float COEF_REDUCE_LEFT_ARM = 0.65;

int lowerTo180(int val){
	if (abs(val) > MAX_MOTOR_POWER) {
		if(val < 0) return -MAX_MOTOR_POWER;
		else        return MAX_MOTOR_POWER;
	}
	else return val;
}

// *********************   DRIVE  ***********************///
int x;
int y;
int z;
void drive(int xDrive, int yDrive, int turn){
	x = abs(xDrive) > DEADZONE ? -xDrive : 0;
	y = abs(yDrive) > DEADZONE ? -yDrive : 0;
	z = abs(turn) > DEADZONE ? turn : 0;

	motor[dTLeft]  = lowerTo180(x+y-z);
	motor[dTRight] = lowerTo180(x-y-z);
	motor[dBLeft]  = lowerTo180(x-y+z);
	motor[dBRight] = lowerTo180(x+y+z);
}


// **********************  HUG  *************************///

void hug(int in) {
	// use right side for in
	//int in = CLAW_SPEED * (vexRT[Btn6U] - vexRT[Btn6D]);
	motor[lClaw] = COEF_REDUCE_LEFT_ARM*in;
	motor[rClaw] = in;
}

// *********************  LIFT  **************************//

void lift(int power) {
	motor[lTLeft] = power;
	motor[lBLeft] =  power;
	motor[lTRight] = -power;
	motor[lBRight] = -power;
}


//********************  AUTON FUNCTIONS   *******************************
// HUG
int autonHugTime;
int autonHugDir;
task autonHugHandler() {
	hug((autonHugDir*CLAW_SPEED));
	wait1Msec(autonHugTime);
	hug(0);
	stopTask(autonHugHandler);
}

void asyncAutonHug(int dir, int time) {
	autonHugTime = time;
	autonHugDir = dir;
	startTask(autonHugHandler);
}

// DRIVE
int autonXDrive;
int autonYDrive;
int autonTurn;
int autonDriveTime;
task autonDriveHandler() {
	drive(autonXDrive, autonYDrive, autonTurn);
	wait1Msec(autonDriveTime);
	drive(0,0,0);
	stopTask(autonDriveHandler);
}

void asyncAutonDrive(int xDrive, int yDrive, int turn, int time) {
	autonXDrive = xDrive;
	autonYDrive = yDrive;
	autonTurn = turn;
	autonDriveTime = time;
	startTask(autonDriveHandler);
}

// LIFT
int autonLiftPower;
int autonLiftTime;
task autonLiftHandler() {
	lift(autonLiftPower);
	wait1Msec(autonLiftTime);
	lift(0);
	stopTask(autonLiftHandler);
}


void asyncAutonLift(int power, int time){
	autonLiftPower = power;
	autonLiftTime = time;
	startTask(autonLiftHandler);
}

// Actual Auton
void pre_auton()
{
  bStopTasksBetweenModes = true;
}

// USEFUL AUTON CONST
const int ROT_TIME_90_DEGREES = 650;

// time var always last
task autonomous()
{
		asyncAutonHug(1, ROT_TIME_90_DEGREES);  // 1 is inward rotation - 650 is for 90 rotation
		asyncAutonDrive(0,180,0,1000);
		wait1Msec(1000);
		asyncAutonLift(MAX_MOTOR_POWER, 500);
}

task userDriveTask(){ while(true)	drive(vexRT[Ch4], vexRT[Ch3], vexRT[Ch1]); /*X, Y, Turn*/ }
task userHugTask()  { while(true) hug(CLAW_SPEED * (vexRT[Btn6U] - vexRT[Btn6D]));}
task userLiftTask() { while(true) lift(MAX_MOTOR_POWER*(vexRT[Btn5U] - vexRT[Btn5D]));}

task usercontrol()
{
  startTask(userDriveTask);
	startTask(userHugTask);
	startTask(userLiftTask);
}
