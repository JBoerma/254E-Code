#pragma config(Sensor, in1,    cLeft,          sensorPotentiometer)
#pragma config(Sensor, in2,    cRight,         sensorPotentiometer)
#pragma config(Motor,  port1,           lBRight,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           dTRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rClaw,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           dTLeft,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lTRight,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           dBLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lTLeft,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dBRight,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lClaw,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          lBLeft,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// d at beginning means drive
// l at beginning beans lift
// r & l at beginning are for claw

// TODO: get the potentiometers working
// TODO: refactor code for auton & make auton



#pragma platform(VEX2);
#pragma competitionControl(Competition);
#include "Vex_Competition_Includes.c";


int lowerTo180(int val){
	if (abs(val) > 180) {
		if(val < 0)
			return -180;
		else
			return 180;
	}
	else return val;
}

int DEADZONE = 10;


int x;
int y;
int z;
void drive(int X_DRIVE, int Y_DRIVE, int TURN){
	x = abs(X_DRIVE) > DEADZONE ? -X_DRIVE : 0;
	y = abs(Y_DRIVE) > DEADZONE ? -Y_DRIVE : 0;
	z = abs(TURN) > DEADZONE ? TURN : 0;

	motor[dTLeft]  = lowerTo180(x+y-z);
	motor[dTRight] = lowerTo180(x-y-z);
	motor[dBLeft]  = lowerTo180(x-y+z);
	motor[dBRight] = lowerTo180(x+y+z);
}

int CLAW_SPEED = 70;
void hug(int in) {
	// use right side for in
	//int in = CLAW_SPEED * (vexRT[Btn6U] - vexRT[Btn6D]);
	motor[lClaw] = .65*in;  // temp - will fix with potentiometer code
	motor[rClaw] = in;
}

int liftSpeed = 127;
void lift() {
	int up = (int) liftSpeed*(vexRT[Btn5U] - vexRT[Btn5D]);
	motor[lTLeft] = up;
	motor[lBLeft] =  up;
	motor[lTRight] = -up;
	motor[lBRight] = -up;
}


//********************  AUTON FUNCTIONS   *******************************

void autonHug(int time, int dir) {  // if enumerators work - make this a function of rotation // dir is 1 or -1
	hug((dir*CLAW_SPEED));
	wait1Msec(time);
	hug(0);
}

int autonHugTime;
int autonHugDir;
task autonHugHandler() {
	autonHug(autonHugTime, autonHugDir);
	stopTask(autonHugHandler);
}

void asyncAutonHug(int time, int dir) {
	writeDebugStreamLine("asyncAutonHug was called");
	autonHugTime = time;
	autonHugDir = dir;
	startTask(autonHugHandler);
}

void autonDrive(int X_DRIVE, int Y_DRIVE, int TURN, int time) {
	writeDebugStreamLine("autonDrive was called");
	drive(X_DRIVE, Y_DRIVE, TURN);
	wait1Msec(time);
	drive(0,0,0);
}

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{
	//motor[dBLeft] = 50;
	writeDebugStream("autonomous is happening");
	asyncAutonHug(650, 1);
}


task driveTask() {
	while(true){
		drive(vexRT[Ch4], vexRT[Ch3], vexRT[Ch1]); // X, Y, Turn
	}
}

task usercontrol()
{
  startTask(driveTask);
	while(true){
		//drive(vexRT[Ch4], vexRT[Ch3], vexRT[Ch1]); // X, Y, Turn
		hug(CLAW_SPEED * (vexRT[Btn6U] - vexRT[Btn6D]));
		lift();
	}
}
